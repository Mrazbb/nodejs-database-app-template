const REG_SPLIT = /[ ,]+/;


// Import the dotenv package
const dotenv = require('dotenv');
const fs = require('fs');
const path = require('path');

// Read and parse the .env file
const envFilePath = path.resolve(__dirname, '../.env.main');


const envConfig = dotenv.parse(fs.readFileSync(envFilePath));
const env = { ...envConfig };


const apps = env[ 'apps' ]?.split(REG_SPLIT)?.filter(app => app.trim() !== '');

console.log(apps);


if (apps?.length  && apps.length > 0) {
    apps.forEach(app => {
        const domainsKey = `${app}_domains`;
        const redirectKey = `${app}_redirect_from_non_www`;
    const portKey = `${app}_port`;
    const ipwhitelistKey = `${app}_ipwhitelist`;

    if (env[domainsKey]) {
        const domains = env[domainsKey].split(REG_SPLIT).map(domain => domain.trim()).filter(domain => domain !== '');

        env[`${app}_traefik_domains`] =  "'" + domains.map(domain => `Host(\`${domain}\`)`).join(' || ') + "'";

        if (domains.length > 0) 
            env[`${app}_url`] = domains[0];

        if (env[redirectKey] === 'true') {
            env[`${app}_traefik_redirect_to_www`] =  "'" + domains.map(domain => `Host(\`${domain.replace('www.', '')}\`)`).join(' || ') + "'";
        } else {
            env[`${app}_traefik_redirect_to_www`] =  "'Host(`xxx.example.com`)'"
        }

        if (env[ipwhitelistKey]) {
            const ipwhitelist = env[ipwhitelistKey].split(REG_SPLIT).map(ip => ip.trim()).filter(ip => ip !== '');

            if (env['environment'] == 'dev') {
                env[`${app}_traefik_ipwhitelist`] =  "'" + ipwhitelist.map(ip => `ClientIP(\`${ip}\`)`).join(' || ') + "'";
            } else {
                // all
                env[`${app}_traefik_ipwhitelist`] =  "'!ClientIP(`0.0.0.0/0`)'";
            }

            console.log('ipwhitelist', env[`${app}_traefik_ipwhitelist`]);
        }


    }

        env[`docker_container_${app}`] = `${env.COMPOSE_PROJECT_NAME}_${app}`;
    });
}


env[ 'docker_container_pg' ] = env[ 'COMPOSE_PROJECT_NAME' ] + '_postgres';

if (env[ 'docker_container_pg' ] && env[ 'postgres_user' ] && env[ 'postgres_password' ] && env[ 'postgres_db' ]) {
    env[ 'postgres' ] = `${env['postgres_user']}:${env['postgres_password']}@${env['docker_container_pg']}/${env['postgres_db']}`;
}


// Log the dictionary to verify
configfile = '# This file is generated by generate_config.js\n';
envfile = '# This file is generated by generate_config.js\n';

Object.keys(env).forEach((key) => {
    if(['api', 'cors', 'tmsurl', 'tms'].includes(key)) {
        configfile += `$`;
    }
    configfile += `${key} : ${env[ key ]}\n`;
    envfile += `${key}=${env[ key ]}\n`;
});

//------------ ALTERGEN ------------

// Build altergen.json content from env variables
const altergenConfig = {
    postgres: env['altergen_postgres'],
    source_dir: env['altergen_source_dir'],
    additional_source_dirs: env['altergen_additional_source_dirs']?.split(REG_SPLIT).map(dir => dir.trim()).filter(dir => dir !== ''),
    output_file: env['altergen_output_file'],
    drop_columns_file: env['altergen_drop_columns_file'],
    create_drop_columns_file: env['altergen_create_drop_columns_file'] === 'true',
    insert: env['altergen_insert'] === 'true',
    update: env['altergen_update'] === 'true',
    insert_if_not_exists: env['altergen_insert_if_not_exists'] === 'true'
};



fs.writeFileSync(path.resolve(__dirname, '../config'), configfile);
fs.writeFileSync(path.resolve(__dirname, '../.env'), envfile);

console.log('Config file generated successfully');